# 货车运输问题的图算法研究与实现

## 项目背景

本项目基于 NOIP 2013 提高组的经典算法题目"货车运输"，旨在探索和对比解决该问题的两种不同算法方案。该问题是图论中最大生成树（Maximum Spanning Tree）与最近公共祖先（Lowest Common Ancestor, LCA）算法的经典应用场景。

## 问题描述

### 场景设定
A 国有 n 座城市（编号 1 到 n），城市之间有 m 条双向道路。每条道路都有重量限制（限重）。现在有 q 辆货车需要运输货物，每辆货车都需要从起点城市运输到终点城市。

### 核心问题
对于每辆货车，在不超过道路限重的情况下，它能运输的最大货物重量是多少？

### 关键约束
- 货车必须经过的每一条道路都不能超过该道路的限重
- 货车的最大载重量取决于路径中限重最小的那条道路（木桶效应）
- 如果两个城市不连通，则无法运输，输出 -1

### 问题本质
这是一个在图中寻找两点间路径上"最小边权的最大值"问题。换句话说：
- 在所有从 x 到 y 的可能路径中
- 每条路径有一个"瓶颈"（路径上的最小边权）
- 我们要找到瓶颈最大的那条路径

## 算法思路

### 核心观察
对于这个问题，有一个关键性质：**从 x 到 y 能承受最大载重的路径，一定在原图的最大生成树上**。

证明思路：
1. 如果最优路径不在最大生成树上，那么这条路径上必然存在一条边 e 不在最大生成树中
2. 由于是最大生成树，树上从 x 到 y 的路径中的所有边都不小于 e（否则 e 应该被加入生成树）
3. 因此树上路径的瓶颈不会比原路径的瓶颈小
4. 所以我们只需要在最大生成树上寻找答案

### 解决方案
1. **第一步**：使用 Kruskal 算法构建原图的最大生成森林（可能有多个连通分量）
2. **第二步**：对于每个查询 (x, y)，在生成树上找到 x 到 y 的路径上的最小边权

第一步是两种方法的共同部分，区别在于第二步如何高效地查询路径上的最小边权。

## 两种实现方案

### 方案一：倍增算法 (Binary Lifting)

**算法原理：**
- 预处理每个节点向上跳 2^k 步的祖先节点
- 同时维护跳跃过程中经过的最小边权
- 查询时，将两个节点提升到同一深度，然后同时向上跳跃至 LCA
- 在跳跃过程中更新路径上的最小边权

**时间复杂度：**
- 预处理：O(n log n)
- 单次查询：O(log n)
- 总体：O((n + q) log n)

**空间复杂度：** O(n log n)

**优点：**
- 实现相对简单，代码清晰
- 查询效率稳定
- 对树的结构没有特殊要求

**缺点：**
- 需要额外的 O(n log n) 空间存储倍增数组
- 预处理时间较长

### 方案二：树链剖分 (Heavy-Light Decomposition)

**算法原理：**
- 将树分解为若干条重链和轻链
- 通过 DFS 预处理每个节点的深度、父节点、重儿子、所在链的顶端等信息
- 查询 LCA 时，通过跳链快速找到最近公共祖先
- 在本问题中，通过将边转化为虚拟节点来存储边权

**时间复杂度：**
- 预处理：O(n)
- 单次查询：O(log n)（均摊）
- 总体：O(n + q log n)

**空间复杂度：** O(n)

**优点：**
- 预处理时间更短
- 空间占用更少
- 可以方便地扩展到支持路径修改等操作

**缺点：**
- 实现较为复杂，需要理解重链剖分的思想
- 代码量较大，调试难度高

## 方案对比分析

| 对比维度 | 倍增算法 | 树链剖分 |
|---------|---------|---------|
| 实现难度 | ⭐⭐ 中等 | ⭐⭐⭐ 较难 |
| 代码长度 | 较短（~120行） | 较长（~120行） |
| 预处理时间 | O(n log n) | O(n) |
| 查询时间 | O(log n) | O(log n) |
| 空间复杂度 | O(n log n) | O(n) |
| 可扩展性 | 较差 | 较好 |
| 适用场景 | 只查询 LCA | 支持树上路径查询和修改 |

## 预期结果

1. **正确性验证**：两种方法对于相同输入应该产生完全一致的输出
2. **性能对比**：在大规模数据（n=10000, q=30000）下对比运行时间
3. **代码质量**：Python 实现应具有良好的模块化设计和代码可读性

## 数据规模

根据题目要求：
- 30% 数据：n < 1000, m < 10000, q < 1000
- 60% 数据：n < 1000, m < 50000, q < 1000
- 100% 数据：n < 10000, m < 50000, q < 30000, z ≤ 100000

## 项目结构

```
cs260/
├── docs/
│   ├── question.md              # 原始题目
│   ├── project_description.md   # 本文档
│   ├── method1_explanation.md   # 倍增算法说明
│   └── method2_explanation.md   # 树链剖分说明
├── refs/
│   ├── method1.cpp              # C++ 参考实现（倍增）
│   └── method2.cpp              # C++ 参考实现（树链剖分）
├── src/
│   ├── common.py                # 公共模块
│   ├── method1_binary_lifting.py  # 倍增算法实现
│   ├── method2_tree_chain.py    # 树链剖分实现
│   └── test_methods.py          # 测试代码
├── done.md                      # 完成记录
└── README.md                    # 项目说明
```

## 学习目标

通过本项目，我们将：
1. 深入理解最大生成树算法（Kruskal）的应用
2. 掌握两种不同的 LCA 算法实现
3. 学习如何将算法竞赛题目转化为工程化的代码
4. 培养算法分析和对比的能力
5. 提升 Python 算法实现的编程能力
